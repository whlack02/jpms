<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>친구랑 걷는 길 - 도트버전</title>
<style>
  body {
    margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #d8f0e3; display: flex; justify-content: center; padding: 20px;
  }
  #game-container {
    width: 800px; margin: 0 auto; position: relative;
  }
  #game {
    width: 100%; height: 400px; border: 2px solid #333;
    background-color: #cde; position: relative; user-select: none;
  }
  canvas {
    width: 100%; height: auto; display: block;
    background: linear-gradient(#a6e3a1, #d8f0e3);
    border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    image-rendering: pixelated; /* 도트 느낌 살리기 */
  }
  #dialogue-box {
    position: absolute; left: 10px; right: 10px; top: 12px;
    background: rgba(255,255,255,0.95);
    border: 2px solid #555; padding: 10px; border-radius: 6px;
    display: none; z-index: 30;
  }
  #closeness-info { font-weight: 700; margin-bottom: 6px; }
  #choices { margin-top: 8px; display:flex; gap:8px; flex-wrap:wrap; }
  #z-prompt { position:absolute; right:8px; bottom:8px; font-size:12px; color:#333; display:none; }
  #exit-btn {
    display: block; width: 10%; min-width: 60px;
    padding: 12px 0; font-size: 18px; border: none; border-radius: 6px;
    background-color: #e74c3c; color: white; cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    margin-top: 8px; margin: 8px auto 0 auto;
    transition: background-color 0.3s ease;
  }
  #exit-btn:hover { background-color: #c0392b; }
  #controls {
    position: absolute; bottom: 20px; left: 12px; right: 12px;
    display: flex; justify-content: space-between; align-items: flex-end;
    pointer-events: none; z-index: 40;
  }
  #joystick {
    pointer-events: auto; width: 120px; height: 120px; border-radius: 50%;
    background: rgba(0,0,0,0.06); position: relative; touch-action: none;
    display:flex; align-items:center; justify-content:center;
  }
  #stick {
    width: 56px; height: 56px; border-radius: 50%;
    background: rgba(0,0,0,0.35);
    transform: translate(0,0);
    transition: transform 0.02s linear;
  }
  #action-area {
    pointer-events: auto; display:flex; flex-direction:column; gap:10px;
  }
  .action-btn {
    width:64px; height:64px; border-radius:50%; border:none;
    font-size:20px; font-weight:700; color:white;
    box-shadow:0 4px 8px rgba(0,0,0,0.2);
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  #e-btn { background:#7f8c8d; cursor: not-allowed; }
  #e-btn.enabled { background:#e74c3c; cursor: pointer; }
  #z-btn { background:#2ecc71; }
  @media (max-width:420px) {
    #joystick { width: 96px; height:96px; }
    #stick { width:46px; height:46px; }
    .action-btn { width:56px; height:56px; font-size:18px; }
  }
</style>
</head>
<body>
<div id="game-container">
  <div id="game" aria-label="게임 영역" role="main" tabindex="0">
    <canvas id="mapCanvas" width="800" height="400" aria-label="게임 지도"></canvas>

    <div id="dialogue-box" role="dialog" aria-hidden="true" aria-live="polite">
      <div id="closeness-info">친밀도: 0</div>
      <div id="npc-text"></div>
      <div id="choices"></div>
      <div id="z-prompt">Z키를 눌러 넘기기</div>
    </div>

    <button id="exit-btn" onclick="window.location.href = 'mainroom.html' ">나가기</button>

    <div id="controls">
      <div id="joystick" aria-label="조이스틱 컨트롤" role="application" tabindex="0"><div id="stick"></div></div>
      <div id="action-area">
        <button id="e-btn" class="action-btn" aria-label="상호작용 (E)" disabled>E</button>
        <button id="z-btn" class="action-btn" aria-label="대화 넘기기 (Z)">Z</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('mapCanvas');
  const ctx = canvas.getContext('2d');
  const LOGICAL_W = canvas.width;
  const LOGICAL_H = canvas.height;
  const WORLD_W = 2200;
  const WORLD_H = LOGICAL_H;

  const TILE_SIZE = 16; // 도트 크기

  // 플레이어 객체
  const player = {
    x: 400,
    y: 200,
    r: 10, // 도트 스타일에 맞게 반지름 감소
    speed: 3,
    facing: 'right',
    isHappy: false,
    happyFrames: 0
  };

  // 친구 생성 함수
  function createFriends() {
    return [
      {
        name: '친구1', x: 600, y: 200, r: 10,
        closeness: 0,
        forgiving: false,
        dialogues: [
          "와, 안왔던 길이네! 기분좋아.",
          "요즘 뭐 재밌는거 해?",
          "함께 걸으니 좋다!",
          "다음에 또 같이 가자!"
        ],
        dialogIdx: 0,
        gender: 'female'
      },
      {
        name: '친구2', x: 960, y: 200, r: 10,
        closeness: 0,
        forgiving: false,
        dialogues: [
          "안녕! 오늘 컨디션 어때?",
          "새로운 가게 생겼더라구.",
          "너랑 이야기하면 시간 가는 줄 몰라.",
          "다음에 또 보자!"
        ],
        dialogIdx: 0,
        gender: 'male'
      },
      {
        name: '친구3', x: 1320, y: 200, r: 10,
        closeness: 0,
        forgiving: true,
        dialogues: [
          "여기 경치 좋네.",
          "이 길을 자주 걸어야겠다.",
          "너도 그렇게 생각하지 않아?",
          "다음에 또 보자!"
        ],
        dialogIdx: 0,
        gender: 'male'
      }
    ];
  }

  let friends = createFriends();

  let currentFriendIndex = null;
  let inDialogue = false;
  let requireZToClose = false;
  let friendlyCount = 0;
  let inHouse = false;
  let houseDialogDone = false;
  let lastFriendTalked = false;

  const dialogueBox = document.getElementById('dialogue-box');
  const npcText = document.getElementById('npc-text');
  const choicesDiv = document.getElementById('choices');
  const closenessInfo = document.getElementById('closeness-info');
  const zPrompt = document.getElementById('z-prompt');
  const eBtn = document.getElementById('e-btn');
  const zBtn = document.getElementById('z-btn');

  let keyLeft = false, keyRight = false;

  // E 버튼 활성화/비활성화
  function setEButtonEnabled(enabled) {
    if (enabled) {
      eBtn.disabled = false;
      eBtn.classList.add('enabled');
    } else {
      eBtn.disabled = true;
      eBtn.classList.remove('enabled');
    }
  }

  // 카메라 X좌표 계산
  function cameraXForPlayer() {
    let camX = player.x - LOGICAL_W / 2;
    camX = Math.max(0, Math.min(camX, WORLD_W - LOGICAL_W));
    return camX;
  }

  // 월드 경계 내 제한
  function clampToWorld(px, py, r) {
    let maxX = WORLD_W - r;
    if (!lastFriendTalked) maxX = 1600; // 마지막 친구 대화 전까지 오른쪽 제한
    const nx = Math.max(r, Math.min(px, maxX));
    const ny = Math.max(r, Math.min(py, WORLD_H - r));
    return { x: nx, y: ny };
  }

  // 충돌 검사 (친구와 겹치는지)
  function isOverlappingWithAny(x, y, ignoreIndex = -1) {
    for (let i = 0; i < friends.length; i++) {
      if (i === ignoreIndex) continue;
      const fr = friends[i];
      const d = Math.hypot(x - fr.x, y - fr.y);
      if (d < player.r + fr.r) return true;
    }
    return false;
  }

  // 플레이어 이동 및 방향 변경 (제자리 회전 포함)
  function tryMove(dx, dy) {
    if (dx !== 0) {
      let nx = player.x + dx;
      let ny = player.y + dy;
      const clamped = clampToWorld(nx, ny, player.r);
      nx = clamped.x; ny = clamped.y;

      if (!isOverlappingWithAny(nx, ny)) {
        player.x = nx; player.y = ny;
      } else {
        if (!isOverlappingWithAny(player.x + dx, player.y)) {
          const c = clampToWorld(player.x + dx, player.y, player.r);
          player.x = c.x;
        } else if (!isOverlappingWithAny(player.x, player.y + dy)) {
          const c = clampToWorld(player.x, player.y + dy, player.r);
          player.y = c.y;
        }
      }
      player.facing = dx > 0 ? 'right' : 'left';
    } else {
      if (keyLeft) player.facing = 'left';
      else if (keyRight) player.facing = 'right';
    }
  }

  // 친구 근처 체크해서 E버튼 활성화
  function updateProximity() {
    if (inHouse) {
      setEButtonEnabled(false);
      return;
    }
    currentFriendIndex = null;
    let foundNearFriend = false;
    for (let i = 0; i < friends.length; i++) {
      const fr = friends[i];
      const dist = Math.hypot(player.x - fr.x, player.y - fr.y);
      if (dist <= player.r + fr.r + 6) {
        currentFriendIndex = i;
        foundNearFriend = true;
        break;
      }
    }
    setEButtonEnabled(foundNearFriend);
  }

  // 대화 열기
  function openDialogue(idx) {
    if (idx === null || idx < 0 || idx >= friends.length) return;
    inDialogue = true;
    dialogueBox.style.display = 'block';
    dialogueBox.setAttribute('aria-hidden', 'false');
    requireZToClose = false;
    zPrompt.style.display = 'none';

    const fr = friends[idx];
    if (!fr) { closeDialogue(); return; }

    closenessInfo.innerText = `${fr.name} 친밀도: ${fr.closeness}`;

    const dIdx = fr.dialogIdx || 0;
    const dialogues = fr.dialogues || [];
    const line = dialogues[dIdx] || `${fr.name}: ...`;
    npcText.innerText = line;

    choicesDiv.innerHTML = `
      <button onclick="choose(0)">좋아!</button>
      <button onclick="choose(1)">그냥 그래</button>
      <button onclick="choose(2)">별로야</button>
    `;
  }

  // 선택 처리
  window.choose = function(option) {
    const idx = currentFriendIndex;
    if (idx === null || !friends[idx]) return;
    const fr = friends[idx];

    let unexpected = false;
    if (fr.name === '친구3') {
      unexpected = Math.random() < 0.10;
    } else {
      unexpected = Math.random() < 100;
    }

    let finalAction = option;
    if (unexpected) {
      const others = [0, 1, 2].filter(i => i !== option);
      finalAction = others[Math.floor(Math.random() * others.length)];
    }

    let delta = 0;
    if (finalAction === 0) delta = 1;
    if (finalAction === 2) delta = -1;
    if (unexpected && !fr.forgiving) delta -= 1;

    // 친구3은 호감도 감소 금지
    if (fr.name === '친구3' && delta < 0) delta = 2;

    fr.closeness += delta;

    npcText.innerText = unexpected ? '앗, 다른 행동을 해버렸어요!' : '좋은 선택이었어요!';
    choicesDiv.innerHTML = `<button onclick="continueDialogue()">대화 이어가기</button>`;
    closenessInfo.innerText = `${fr.name} 친밀도: ${fr.closeness}`;
  }

  // 대화 이어가기 및 종료 처리
  window.continueDialogue = function() {
    const idx = currentFriendIndex;
    if (idx === null) { closeDialogue(); return; }
    const fr = friends[idx];
    if (!fr) { closeDialogue(); return; }

    fr.dialogIdx = (fr.dialogIdx || 0) + 1;

    if (fr.dialogIdx >= (fr.dialogues ? fr.dialogues.length : 4)) {
      const finishedName = fr.name;
      if (fr.closeness >= 2) {
        npcText.innerText = '다음에 또 보자';
        friendlyCount += 1;

        if (finishedName === '친구3') {
          player.isHappy = true;
          player.happyFrames = 60;
          lastFriendTalked = true;
        }
      } else {
        npcText.innerText = '저리가';
      }
      friends.splice(idx, 1);
      currentFriendIndex = null;
      choicesDiv.innerHTML = '';

      if (finishedName === '친구2' && friendlyCount === 0) {
        npcText.innerText = '사람들과 친해지는 게 쉽지 않네..';
        requireZToClose = true;
        zPrompt.style.display = 'block';
      } else {
        choicesDiv.innerHTML = `<button onclick="closeDialogue()">확인</button>`;
        zPrompt.style.display = 'none';
      }
      closenessInfo.innerText = `친해진 사람: ${friendlyCount}`;

      setEButtonEnabled(false);
    } else {
      openDialogue(currentFriendIndex);
    }
  }

  // 대화 닫기
  window.closeDialogue = function() {
    inDialogue = false;
    dialogueBox.style.display = 'none';
    dialogueBox.setAttribute('aria-hidden', 'true');
    currentFriendIndex = null;
    requireZToClose = false;
    zPrompt.style.display = 'none';
    updateProximity();
  }

  // 집 입장 체크
  function checkHouseEntry() {
    if (!lastFriendTalked) return false;
    if (player.x >= 1800 && !inHouse) {
      inHouse = true;
      openHouseDialogue();
      return true;
    }
    return false;
  }

  // 집 내부 대화 열기
  function openHouseDialogue() {
    inDialogue = true;
    houseDialogDone = false;
    dialogueBox.style.display = 'block';
    dialogueBox.setAttribute('aria-hidden', 'false');
    closenessInfo.innerText = '동글이';

    choicesDiv.innerHTML = '';
    zPrompt.style.display = 'none';

    if (friendlyCount == 0) {
      npcText.innerText = "오늘도 친구를 못사귀었어";
    } else {
      npcText.innerText = "나도 친구가 생겼어!";
    }
  }

  // 집 대화 종료 처리 (Z키 누르면)
  function finishHouseDialogue() {
    houseDialogDone = true;
    inDialogue = false;
    inHouse = false;
    dialogueBox.style.display = 'none';
    dialogueBox.setAttribute('aria-hidden', 'true');
    currentFriendIndex = null;
    requireZToClose = false;
    zPrompt.style.display = 'none';
  }

  // 도트 스타일 그리기 헬퍼 - 사각형 픽셀 블록 그리기
  function drawPixelBlock(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, size, size);
  }

  // 도트 스타일 플레이어 그리기
  function drawPlayerDot(px, py) {
    // 기본 몸통 (옷 색)
    drawPixelBlock(px, py, TILE_SIZE, '#212121');  // 모자 몸통 영역

    // 모자 (상단)
    drawPixelBlock(px + 2, py - TILE_SIZE, TILE_SIZE - 4, '#000000');
    drawPixelBlock(px + 2, py - TILE_SIZE + 4, TILE_SIZE - 4, '#333333');

    // 얼굴 (살색)
    drawPixelBlock(px + 4, py - TILE_SIZE + 12, TILE_SIZE - 8, '#fcd7b8');

    // 눈 (검정)
    drawPixelBlock(px + 6, py - TILE_SIZE + 14, 2, '#000000');
    drawPixelBlock(px + 10, py - TILE_SIZE + 14, 2, '#000000');
  }

  // 도트 스타일 친구 그리기 (성별 및 색상 다르게)
  function drawFriendDot(fr, px, py) {
    if (fr.gender === 'female') {
      // 분홍 계열
      drawPixelBlock(px, py, TILE_SIZE, '#ff6f91'); // 몸통
      drawPixelBlock(px + 2, py - TILE_SIZE, TILE_SIZE - 4, '#d14669'); // 머리
      drawPixelBlock(px + 4, py - TILE_SIZE + 10, TILE_SIZE - 8, '#fce4ec'); // 얼굴

      // 눈
      drawPixelBlock(px + 6, py - TILE_SIZE + 12, 2, '#000000');
      drawPixelBlock(px + 10, py - TILE_SIZE + 12, 2, '#000000');
    } else {
      if (fr.name === '친구2') {
        // 파랑 계열
        drawPixelBlock(px, py, TILE_SIZE, '#6a5acd'); // 몸통
        drawPixelBlock(px + 2, py - TILE_SIZE, TILE_SIZE - 4, '#4e4cb8'); // 머리
        drawPixelBlock(px + 4, py - TILE_SIZE + 10, TILE_SIZE - 8, '#c3c4fc'); // 얼굴

        // 눈
        drawPixelBlock(px + 6, py - TILE_SIZE + 12, 2, '#000000');
        drawPixelBlock(px + 10, py - TILE_SIZE + 12, 2, '#000000');
      } else {
        // 보라 계열 (친구3)
        drawPixelBlock(px, py, TILE_SIZE, '#9370db'); // 몸통
        drawPixelBlock(px + 2, py - TILE_SIZE, TILE_SIZE - 4, '#7b5ea0'); // 머리
        drawPixelBlock(px + 4, py - TILE_SIZE + 10, TILE_SIZE - 8, '#e0d1f9'); // 얼굴

        // 눈
        drawPixelBlock(px + 6, py - TILE_SIZE + 12, 2, '#000000');
        drawPixelBlock(px + 10, py - TILE_SIZE + 12, 2, '#000000');
      }
    }
  }

  // 배경 그리기 (잔디 + 집) - 집 몸통을 빨강/하양 벽돌무늬로 변경
  function drawBackground(camX) {
    // 잔디 (초록 배경)
    ctx.fillStyle = '#7bb661';
    ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

    // 집 위치
    const houseX = 1700 - camX;
    const houseY = LOGICAL_H - 300;

    // 벽돌 패턴: 빨강(#c1440e)과 하양(#ffffff)을 번갈아가며, 홀수 줄은 반칸씩 오프셋 해서 벽돌 느낌 연출
    const block = 16;
    const cols = 11; // 열 수
    const rows = 6; // 행 수
    const brickRed = '#c1440e';
    const brickWhite = '#ffffff';
    for (let row = 0; row < rows; row++) {
      const y = houseY + row * block;
      // 홀수 행은 반 블록만큼 왼쪽으로 이동해서 쌓인 벽돌처럼 보이게 함
      const rowOffset = (row % 2 === 1) ? block / 2 : 0;
      for (let col = 0; col < cols; col++) {
        const x = houseX + col * block - rowOffset;
        // 벽돌이 집 영역 바깥으로 나가면 건너뜀
        const houseWidth = cols * block;
        if (x + block <= houseX || x >= houseX + houseWidth) continue;
        // 색 번갈아: (row + col) 기준으로 토글
        const color = ((row + col) % 2 === 0) ? brickRed : brickWhite;
        ctx.fillStyle = color;
        ctx.fillRect(Math.round(x), Math.round(y), block, block);
        // 가느다란 흰색 줄(모르타르 느낌) 추가
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.lineWidth = 1;
        ctx.strokeRect(Math.round(x), Math.round(y), block, block);
      }
    }

    // 지붕 (삼각형 픽셀 아트)
    ctx.fillStyle = '#8b2e0d';
    ctx.beginPath();
    ctx.moveTo(houseX - 10, houseY);
    ctx.lineTo(houseX + 80, houseY - 60);
    ctx.lineTo(houseX + 170, houseY);
    ctx.closePath();
    ctx.fill();

    // 창문 픽셀 단위
    ctx.fillStyle = '#f0e68c';
    ctx.fillRect(houseX + 32, houseY + 48, 48, 40);
    ctx.strokeStyle = '#a69c3a';
    ctx.lineWidth = 2;
    ctx.strokeRect(houseX + 32, houseY + 48, 48, 40);

    // 창문 격자 (픽셀로 나누기)
    ctx.strokeStyle = '#d9d471';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(houseX + 32 + 16, houseY + 48);
    ctx.lineTo(houseX + 32 + 16, houseY + 48 + 40);
    ctx.moveTo(houseX + 32 + 32, houseY + 48);
    ctx.lineTo(houseX + 32 + 32, houseY + 48 + 40);
    ctx.moveTo(houseX + 32, houseY + 48 + 20);
    ctx.lineTo(houseX + 32 + 48, houseY + 48 + 20);
    ctx.stroke();
  }

  // 플레이어 그리기 (도트 스타일)
  function drawPlayer(camX) {
    const px = Math.floor(player.x - camX - TILE_SIZE / 2 );
    const py = Math.floor(player.y - TILE_SIZE);
    drawPlayerDot(px, py);
  }

  // 친구들 그리기 (도트 스타일)
  function drawFriends(camX) {
    friends.forEach(fr => {
      const fx = Math.floor(fr.x - camX - TILE_SIZE / 2);
      const fy = Math.floor(fr.y - TILE_SIZE);
      drawFriendDot(fr, fx, fy);
    });
  }

  // 게임 루프
  function gameLoop() {
    if (!inDialogue && !inHouse) {
      if (keyLeft && !keyRight) tryMove(-player.speed, 0);
      else if (keyRight && !keyLeft) tryMove(player.speed, 0);

      checkHouseEntry();

      updateProximity();
    }

    const camX = cameraXForPlayer();

    drawBackground(camX);
    drawFriends(camX);
    drawPlayer(camX);

    // 플레이어 해피 효과
    if (player.isHappy && player.happyFrames > 0) {
      player.happyFrames--;
      ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
      ctx.beginPath();
      ctx.arc(player.x - camX, player.y, player.r + 30, 0, Math.PI * 2);
      ctx.fill();
    }

    requestAnimationFrame(gameLoop);
  }

  // 키보드 이벤트 처리
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyLeft = true;
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyRight = true;
    if (e.key.toLowerCase() === 'e') {
      if (!eBtn.disabled && !inDialogue && currentFriendIndex !== null) openDialogue(currentFriendIndex);
    }
    if (e.key.toLowerCase() === 'z') {
      if (inDialogue && !requireZToClose) continueDialogue();
      else if (inDialogue && requireZToClose) closeDialogue();
      else if (inHouse && !houseDialogDone) finishHouseDialogue();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keyLeft = false;
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keyRight = false;
  });

  eBtn.addEventListener('click', () => {
    if (!eBtn.disabled && !inDialogue && currentFriendIndex !== null) openDialogue(currentFriendIndex);
  });

  zBtn.addEventListener('click', () => {
    if (inDialogue && !requireZToClose) continueDialogue();
    else if (inDialogue && requireZToClose) closeDialogue();
    else if (inHouse && !houseDialogDone) finishHouseDialogue();
  });

  // 초기화
  function resetGame() {
    friends = createFriends();
    player.x = 400;
    player.y = 200;
    player.isHappy = false;
    player.happyFrames = 0;
    friendlyCount = 0;
    lastFriendTalked = false;
    inDialogue = false;
    inHouse = false;
    houseDialogDone = false;
    currentFriendIndex = null;
    requireZToClose = false;
    setEButtonEnabled(false);
    dialogueBox.style.display = 'none';
  }
  resetGame();
  updateProximity();
  gameLoop();
})();
</script>
</body>
</html>
