<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>안내견과의 산책</title>
  <style>
    :root {
      --bg: #bde0fe;
      --lane: #CC9966;
      --gutter: #999;
      --stripe: #FFCC99;
      --joystick-bg: rgba(255,255,255,.85);

      /* 조이스틱 크기 및 투명도 변수 */
      --joystick-size: clamp(80px, 15vw, 200px);
      --joystick-opacity: 0.4;

      /* 스틱은 조이스틱 크기의 절반 */
      --stick-size: calc(var(--joystick-size) * 0.5);
    }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans KR", sans-serif;
      overflow: hidden;
    }

    #game {
      width: 100vw;
      height: 100vh;
      display: block;
      background: #e8e8ee;
    }

    .hud {
      position: fixed;
      top: calc(10px + env(safe-area-inset-top));
      left: 12px;
      z-index: 5;
    }

    .pill {
      background: rgba(255,255,255,.9);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(0,0,0,.06);
      margin-bottom: 6px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.35);
      z-index: 10;
    }

    .card {
      background: #fff;
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      max-width: min(92vw, 460px);
      box-shadow: 0 14px 36px rgba(0,0,0,.18);
    }

    .card h1 {
      margin-bottom: 8px;
      font-size: 28px;
    }

    .time {
      margin-bottom: 14px;
      font-size: 18px;
      color: #333;
    }

    .actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 14px;
    }

    .btn {
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid #ccc;
      background: #f0f0f0;
      font-weight: 800;
      cursor: pointer;
    }

    .btn.primary {
      background: #fff7d6;
      border-color: #e8d48f;
    }

    .btn.danger {
      background: #ffe6e8;
      border-color: #ffc7cb;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .joystick-container {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(14px + env(safe-area-inset-bottom));
      width: var(--joystick-size);
      height: var(--joystick-size);
      background: var(--joystick-bg);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      z-index: 5;
      user-select: none;
      opacity: var(--joystick-opacity);
    }

    .joystick {
      width: var(--stick-size);
      height: var(--stick-size);
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
      border: 2px solid #888;
      border-radius: 50%;
      transition: transform 0.1s ease-out;
      touch-action: none;
    }

    @media (pointer:fine) {
      .joystick-container {
        opacity: var(--joystick-opacity);
      }
      .joystick-container:hover {
        ;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <!-- 게임 중 항상 보이는 시간 표시만 유지 -->
    <div class="pill" id="timePill">⏱️ 0.00 s</div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1 id="titleText">게임 종료</h1>
      <div class="time" id="finalTime">걸은 시간: 0.00 s</div>

      <div class="actions">
        <button class="btn primary" id="retryBtn">🔁 다시하기</button>
        <button class="btn danger" id="exitBtn">🚪 나가기</button>
      </div>

      <!-- 게임 오버 시에만 나타나는 슬라이더 -->
      <div class="pill">
        조이스틱 크기:
        <input type="range" id="sizeRange" min="80" max="300" step="1" value="200" />
        
      </div>
      <div class="pill">
        조이스틱 투명도:
        <input type="range" id="opacityRange" min="0" max="1" step="0.05" value="0.4" />
      </div>
    </div>
  </div>

  <div class="joystick-container" id="joystickContainer">
    <div class="joystick" id="joystick"></div>
  </div>

  <script>
  (() => {
    // --- DOM 요소 ---
    const cvs       = document.getElementById('game');
    const ctx       = cvs.getContext('2d');
    const overlay   = document.getElementById('overlay');
    const retryBtn  = document.getElementById('retryBtn');
    const exitBtn   = document.getElementById('exitBtn');
    const timePill  = document.getElementById('timePill');
    const titleText = document.getElementById('titleText');
    const sizeRange = document.getElementById('sizeRange');
    const opacityRange = document.getElementById('opacityRange');

    const joyContainer = document.getElementById('joystickContainer');
    const joyStick     = document.getElementById('joystick');
    let joyDir = { x:0, y:0 };

    // 초기 CSS 변수 세팅
    document.documentElement.style.setProperty('--joystick-size', sizeRange.value + 'px');
    document.documentElement.style.setProperty('--joystick-opacity', opacityRange.value);

    // 슬라이더 이벤트 바인딩
    sizeRange.addEventListener('input', e => {
      document.documentElement.style.setProperty('--joystick-size', e.target.value + 'px');
    });
    opacityRange.addEventListener('input', e => {
      document.documentElement.style.setProperty('--joystick-opacity', e.target.value);
    });

    // --- 레이아웃 & 레인 계산 ---
    const lane = { x1:0, x2:0 };
    function resize(){
      cvs.width  = innerWidth;
      cvs.height = innerHeight;
      const W = cvs.width;
      const laneW = Math.min(W <= 768 ? 360 : 700, W - (W <= 768 ? 40 : 160));
      lane.x1 = (W - laneW)/2;
      lane.x2 = lane.x1 + laneW;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 상수 & 상태 ---
    const DOG         = { r:18, speed:170, color:'#d4a44a', ear:'#9c6f2f', outline:'#101010' };
    const HUMAN       = { r:14, speed:100, color:'#fdd086' };
    const MAX_DIST    = 100;
    const WARNING_DIST= MAX_DIST * 0.7;
    const TRAIL_STEP  = 4, LAG_STEPS = 3, FOLLOW_DIST = 20, BEHIND_BIAS = 0.75;
    const MIN_SEP     = DOG.r + HUMAN.r + 4;
    const GRACE_MS    = 700;
    const MAX_DIFF    = 3, TIME_TO_MAX = 60;

    let warningBlinkTimer = 0;
    let isWarning         = false;

    let dog    = { x:0, y:0, vx:0, vy:0 };
    let human  = { x:0, y:0, vx:0, vy:0 };
    let dogDir = { x:0, y:-1 };
    let prevDog, trail = [];
    let elapsed = 0, running = true, difficulty = 1;
    let lastFrame = performance.now(), startTime;

    // --- 장애물 ---
    class Obstacle {
      constructor(type){ this.type = type; this.reset(); }
      reset(){
        this.r  = this.type.randomR();
        this.x  = lane.x1 + 18 + Math.random()*(lane.x2-lane.x1-36);
        this.y  = -this.r - Math.random()*innerHeight*1.2;
        this.vy = this.type.randomSpeed();
      }
      update(dt){
        this.y += this.vy * difficulty * dt;
        if (this.y - this.r > innerHeight) this.reset();
      }
      draw(){ this.type.draw(ctx, this.x, this.y, this.r); }
    }
    const ObTypes = [
      {
        randomR: ()=>16+Math.random()*6,
        randomSpeed: ()=>200+Math.random()*160,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#f97316';
          ctx.beginPath();
          ctx.moveTo(0,-r);
          ctx.lineTo(r*0.8,r*0.9);
          ctx.lineTo(-r*0.8,r*0.9);
          ctx.closePath(); ctx.fill();
          ctx.fillStyle='#fff';
          ctx.fillRect(-r*0.5,-r*0.3,r,r*0.18);
          ctx.fillRect(-r*0.45,r*0.2,r,r*0.16);
          ctx.restore();
        }
      },
      {
        randomR: ()=>14+Math.random()*5,
        randomSpeed: ()=>200+Math.random()*160,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#555';
          ctx.fillRect(-r*0.4,-r*1.6,r*0.8,r*2.2);
          ctx.fillStyle='#ffcc00';
          ctx.fillRect(-r*0.5,-r*0.6,r,r*0.25);
          ctx.fillRect(-r*0.5,0,r,r*0.25);
          ctx.restore();
        }
      },
      {
        randomR: ()=>18+Math.random()*6,
        randomSpeed: ()=>200+Math.random()*160,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#1f6b3a';
          ctx.fillRect(-r*0.8,-r*1.1,r*1.6,r*1.8);
          ctx.fillStyle='#184e2b';
          ctx.fillRect(-r*0.9,-r*1.2,r*1.8,r*0.25);
          ctx.restore();
        }
      },
      {
        randomR: ()=>18+Math.random()*5,
        randomSpeed: ()=>200+Math.random()*160,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#2f2f2f';
          ctx.beginPath(); ctx.arc(0,0,r,0,2*Math.PI); ctx.fill();
          ctx.strokeStyle='#555'; ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(0,0,r*0.7,0,2*Math.PI); ctx.stroke();
          ctx.restore();
        }
      }
    ];
    let obstacles = [];
    function spawnObstacles(){
      const count = Math.max(10, Math.floor((lane.x2-lane.x1)/90));
      obstacles = Array.from({length:count}, ()=>
        new Obstacle(ObTypes[Math.floor(Math.random()*ObTypes.length)])
      );
    }

    // --- 입력 ---
    const keys = {};
    ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD']
      .forEach(c=> keys[c]=false);
    window.addEventListener('keydown', e=>{
      if(e.code in keys){ keys[e.code]=true; e.preventDefault(); }
    });
    window.addEventListener('keyup', e=>{
      if(e.code in keys){ keys[e.code]=false; e.preventDefault(); }
    });

    // 조이스틱
    let dragging=false, origin={x:0,y:0};
    joyContainer.addEventListener('pointerdown', e=>{
      e.preventDefault();
      dragging = true;
      origin.x = e.clientX;
      origin.y = e.clientY;
    });
    window.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx = e.clientX - origin.x;
      const dy = e.clientY - origin.y;
      const max = joyContainer.clientWidth/2 - 12;
      const dist = Math.min(Math.hypot(dx,dy), max);
      const ang = Math.atan2(dy,dx);
      const tx = Math.cos(ang)*dist;
      const ty = Math.sin(ang)*dist;
      joyStick.style.transform = `translate(${tx}px,${ty}px)`;
      joyDir.x = Math.cos(ang)*(dist/max);
      joyDir.y = Math.sin(ang)*(dist/max);
    });
    window.addEventListener('pointerup', ()=>{
      dragging = false;
      joyStick.style.transform = 'translate(0,0)';
      joyDir = { x:0, y:0 };
    });

    function clampToLane(p, r){
      p.x = Math.max(lane.x1+r, Math.min(lane.x2-r, p.x));
      p.y = Math.max(r, Math.min(innerHeight-r, p.y));
    }
    function vecInput(){
      let x = (keys.ArrowRight||keys.KeyD) - (keys.ArrowLeft||keys.KeyA);
      let y = (keys.ArrowDown ||keys.KeyS) - (keys.ArrowUp  ||keys.KeyW);
      x += joyDir.x;
      y += joyDir.y;
      const m = Math.hypot(x,y);
      return m>1 ? { x:x/m, y:y/m } : { x,y };
    }

    // --- 리셋 ---
    function reset(){
      resize();
      dog.x = (lane.x1+lane.x2)/2;
      dog.y = innerHeight - 140;
      dog.vx = dog.vy = 0;

      human.x = dog.x;
      human.y = dog.y + Math.max(FOLLOW_DIST, MIN_SEP);
      human.vx = human.vy = 0;

      trail.length = 0;
      elapsed = 0;
      running = true;
      difficulty = 1;
      warningBlinkTimer = 0;
      isWarning = false;

      prevDog = { x:dog.x, y:dog.y };
      spawnObstacles();
      startTime = performance.now();
      overlay.style.display = 'none';
    }

    // --- 업데이트 ---
    function update(dt){
      if(!running) return;
      elapsed += dt;
      difficulty = 1 + (MAX_DIFF-1)*Math.min(elapsed/TIME_TO_MAX,1);

      // 개 이동
      const dir = vecInput();
      dog.x += dir.x * DOG.speed * dt;
      dog.y += dir.y * DOG.speed * dt;
      clampToLane(dog, DOG.r);

      // 거리 계산
      const dx = dog.x - human.x;
      const dy = dog.y - human.y;
      const dist = Math.hypot(dx, dy);

      // 경고
      if(dist > WARNING_DIST && dist <= MAX_DIST){
        isWarning = true;
        warningBlinkTimer += dt;
      } else {
        isWarning = false;
        warningBlinkTimer = 0;
      }
      // 줄 끊김
      if(dist > MAX_DIST){
        running = false;
        titleText.textContent = '줄이 끊어졌다';
      }

      // 트레일
      if((trail._acc = (trail._acc||0) + dt*60) >= TRAIL_STEP){
        trail._acc = 0;
        trail.push({ x:dog.x, y:dog.y });
        if(trail.length > 1000) trail.shift();
      }

      // 개 방향 보정
      const mvx = dog.x - prevDog.x;
      const mvy = dog.y - prevDog.y;
      const mlen = Math.hypot(mvx, mvy);
      if(mlen > 0.15){
        const nx = mvx/mlen;
        const ny = mvy/mlen;
        dogDir.x = dogDir.x*0.7 + nx*0.3;
        dogDir.y = dogDir.y*0.7 + ny*0.3;
        const dn = Math.hypot(dogDir.x, dogDir.y);
        dogDir.x /= dn;
        dogDir.y /= dn;
      }
      prevDog.x = dog.x;
      prevDog.y = dog.y;

      // 사람 이동
      let tx = dog.x - dogDir.x * FOLLOW_DIST;
      let ty = dog.y - dogDir.y * FOLLOW_DIST;
      if(trail.length > LAG_STEPS){
        const pt = trail[trail.length - LAG_STEPS];
        tx = tx * (1 - BEHIND_BIAS) + pt.x * BEHIND_BIAS;
        ty = ty * (1 - BEHIND_BIAS) + pt.y * BEHIND_BIAS;
      }
      const hx = tx - human.x;
      const hy = ty - human.y;
      const hdist = Math.hypot(hx, hy);
      if(hdist < 1.2){
        human.x = tx;
        human.y = ty;
        human.vx = human.vy = 0;
      } else {
        const nx = hx/hdist;
        const ny = hy/hdist;
        const maxS = Math.min(HUMAN.speed * (1 + Math.min(0.6, hdist/50)), 270);
        const desiredVx = nx * maxS;
        const desiredVy = ny * maxS;
        human.vx += (desiredVx - human.vx) * Math.min(1, 800 * dt);
        human.vy += (desiredVy - human.vy) * Math.min(1, 800 * dt);
        human.vx *= 1 - Math.min(0.9, 16 * dt);
        human.vy *= 1 - Math.min(0.9, 16 * dt);
        const vmag = Math.hypot(human.vx, human.vy);
        if(vmag > maxS){
          human.vx = human.vx / vmag * maxS;
          human.vy = human.vy / vmag * maxS;
        }
        human.x += human.vx * dt;
        human.y += human.vy * dt;
      }

      // 앞질렀을 때 보정
      {
        const relx = human.x - dog.x;
        const rely = human.y - dog.y;
        const proj = relx * dogDir.x + rely * dogDir.y;
        if(proj > 6){
          const bx = dog.x - dogDir.x * Math.max(FOLLOW_DIST, 10);
          const by = dog.y - dogDir.y * Math.max(FOLLOW_DIST, 10);
          const blend = Math.min(1, 10 * dt);
          human.x += (bx - human.x) * blend;
          human.y += (by - human.y) * blend;
          human.vx *= 0.5;
          human.vy *= 0.5;
        }
      }

      // 겹침 방지
      {
        const ddx = dog.x - human.x;
        const ddy = dog.y - human.y;
        const sep = Math.hypot(ddx, ddy);
        if(sep < MIN_SEP){
          const nx = sep > 0 ? ddx/sep : dogDir.x;
          const ny = sep > 0 ? ddy/sep : dogDir.y;
          const fix = MIN_SEP - sep;
          human.x -= nx * fix;
          human.y -= ny * fix;
          human.vx *= 0.5;
          human.vy *= 0.5;
        }
      }
      clampToLane(human, HUMAN.r);

      // 장애물 및 충돌
      obstacles.forEach(o => o.update(dt));
      if(performance.now() - startTime > GRACE_MS){
        for(const o of obstacles){
          if(Math.hypot(o.x - dog.x, o.y - dog.y) < o.r + DOG.r ||
             Math.hypot(o.x - human.x, o.y - human.y) < o.r + HUMAN.r){
            running = false;
            titleText.textContent = '게임 종료';
            break;
          }
        }
      }

      timePill.textContent = `⏱️ ${elapsed.toFixed(2)} s`;
      if(!running){
        document.getElementById('finalTime').textContent = `걸은 시간: ${elapsed.toFixed(2)} s`;
        overlay.style.display = 'flex';
      }
    }

    // --- 그리기 ---
    function draw(){
      // 보도
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--lane');
      ctx.fillRect(lane.x1, 0, lane.x2 - lane.x1, innerHeight);

      // 패턴
      const ts = 40;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--stripe');
      ctx.lineWidth = 1;
      for(let y = 0; y < innerHeight; y += ts){
        for(let x = lane.x1; x < lane.x2; x += ts){
          ctx.strokeRect(x, y, ts, ts);
        }
      }

      // 인도 외곽
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gutter');
      ctx.fillRect(0, 0, lane.x1, innerHeight);
      ctx.fillRect(lane.x2, 0, innerWidth - lane.x2, innerHeight);

      // 장애물
      obstacles.forEach(o => o.draw());

      // 하네스
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(human.x, human.y);
      ctx.lineTo(dog.x, dog.y);
      ctx.stroke();

      // 사람
      ctx.fillStyle = HUMAN.color;
      ctx.beginPath();
      ctx.arc(human.x, human.y, HUMAN.r, 0, 2*Math.PI);
      ctx.fill();

      // 개
      const ang = Math.atan2(dogDir.y, dogDir.x) + Math.PI/2;
      ctx.save();
      ctx.translate(dog.x, dog.y);
      ctx.rotate(ang);
      // 몸통
      ctx.fillStyle = DOG.color;
      ctx.strokeStyle = DOG.outline;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.ellipse(0, 4, DOG.r*0.9, DOG.r*1.1, 0, 0, 2*Math.PI);
      ctx.fill(); ctx.stroke();
      // 머리
      ctx.beginPath();
      ctx.arc(0, -DOG.r*0.6, DOG.r*0.6, 0, 2*Math.PI);
      ctx.fill(); ctx.stroke();
      // 귀
      ctx.fillStyle = DOG.ear;
      ctx.beginPath();
      ctx.arc(-DOG.r*0.35, -DOG.r*0.95, DOG.r*0.22, 0, 2*Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(DOG.r*0.35, -DOG.r*0.95, DOG.r*0.22, 0, 2*Math.PI);
      ctx.fill();
      // 꼬리
      ctx.strokeStyle = DOG.outline;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, DOG.r*1.3);
      ctx.quadraticCurveTo(DOG.r*0.6, DOG.r*1.0, DOG.r*1.0, DOG.r*1.6);
      ctx.stroke();
      ctx.restore();

      // 경고 메시지
      if(isWarning){
        const alpha = Math.abs(Math.sin(warningBlinkTimer * Math.PI * 3));
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = 'red';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('줄이 팽팽하다', dog.x, dog.y - DOG.r - 10);
        ctx.restore();
      }
    }

    // --- 메인 루프 ---
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.033, (now - lastFrame)/1000);
      lastFrame = now;
      update(dt);
      ctx.clearRect(0, 0, innerWidth, innerHeight);
      draw();
      requestAnimationFrame(loop);
    }

    retryBtn.addEventListener('click', reset);
    exitBtn .addEventListener('click', ()=> location.href='mainroom.html');

    reset();
    loop();
  })();
  </script>
</body>
</html>

