<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>안내견과의 산책</title>
  <style>
    :root {
      --bg: #bde0fe;
      --lane: #CC9966;
      --gutter: #999;
      --stripe: #FFCC99;
      --joystick-bg: rgba(255,255,255,.85);

      /* 조이스틱 크기 및 투명도 변수 */
      --joystick-size: clamp(80px, 15vw, 200px);
      --joystick-opacity: 0.4;

      /* 스틱은 조이스틱 크기의 절반 */
      --stick-size: calc(var(--joystick-size) * 0.5);
    }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans KR", sans-serif;
      overflow: hidden;
    }

    #game {
      width: 100vw;
      height: 100vh;
      display: block;
      background: #e8e8ee;
    }

    .hud {
      position: fixed;
      top: calc(10px + env(safe-area-inset-top));
      left: 12px;
      z-index: 5;
    }

    .pill {
      background: rgba(255,255,255,.9);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(0,0,0,.06);
      margin-bottom: 6px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.35);
      z-index: 10;
    }

    .card {
      background: #fff;
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      max-width: min(92vw, 460px);
      box-shadow: 0 14px 36px rgba(0,0,0,.18);
    }

    .card h1 {
      margin-bottom: 8px;
      font-size: 28px;
    }

    .time {
      margin-bottom: 14px;
      font-size: 18px;
      color: #333;
    }

    .actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 14px;
    }

    .btn {
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid #ccc;
      background: #f0f0f0;
      font-weight: 800;
      cursor: pointer;
    }

    .btn.primary {
      background: #fff7d6;
      border-color: #e8d48f;
    }

    .btn.danger {
      background: #ffe6e8;
      border-color: #ffc7cb;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .joystick-container {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(14px + env(safe-area-inset-bottom));
      width: var(--joystick-size);
      height: var(--joystick-size);
      background: var(--joystick-bg);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      z-index: 5;
      user-select: none;
      opacity: var(--joystick-opacity);
    }

    .joystick {
      width: var(--stick-size);
      height: var(--stick-size);
      background: radial-gradient(circle at 30% 30%, #fff, #ccc);
      border: 2px solid #888;
      border-radius: 50%;
      transition: transform 0.1s ease-out;
      touch-action: none;
    }

    @media (pointer:fine) {
      .joystick-container {
        opacity: var(--joystick-opacity);
      }
      .joystick-container:hover {
        ;
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <!-- 게임 중 항상 보이는 시간 표시만 유지 -->
    <div class="pill" id="timePill">⏱️ 0.00 s</div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1 id="titleText">게임 종료</h1>
      <div class="time" id="finalTime">걸은 시간: 0.00 s</div>

      <div class="actions">
        <button class="btn primary" id="retryBtn">🔁 다시하기</button>
        <button class="btn danger" id="exitBtn">🚪 나가기</button>
      </div>

      <!-- 게임 오버 시에만 나타나는 슬라이더 -->
      <div class="pill">
        조이스틱 크기:
        <input type="range" id="sizeRange" min="80" max="300" step="1" value="200" />
      </div>
      <div class="pill">
        조이스틱 투명도:
        <input type="range" id="opacityRange" min="0" max="1" step="0.05" value="0.4" />
      </div>
    </div>
  </div>

  <div class="joystick-container" id="joystickContainer">
    <div class="joystick" id="joystick"></div>
  </div>

  <script>
  (() => {
    // --- 전역 변수 & 상태 ---
    const cvs    = document.getElementById('game');
    const ctx    = cvs.getContext('2d');
    const overlay   = document.getElementById('overlay');
    const retryBtn  = document.getElementById('retryBtn');
    const exitBtn   = document.getElementById('exitBtn');
    const timePill  = document.getElementById('timePill');
    const titleText = document.getElementById('titleText');
    const sizeRange = document.getElementById('sizeRange');
    const opacityRange = document.getElementById('opacityRange');
    const joyContainer = document.getElementById('joystickContainer');
    const joyStick     = document.getElementById('joystick');

    let joyDir = { x: 0, y: 0 };
    let lane = { x1:0, x2:0 };
    let items = [];               // 화면에 떠 있는 아이템 (최대 1개)
    let itemSpawnAcc = 0;         // 1초 누적 스폰 카운터
    let shieldActive = false;     // 실드 발동 여부

    const DOG   = { r:18, speed:170, color:'#d4a44a', ear:'#9c6f2f', outline:'#101010' };
    const HUMAN = { r:14, speed:100, color:'#fdd086' };
    const MAX_DIST    = 100;
    const WARNING_DIST= MAX_DIST * 0.7;
    const TRAIL_STEP  = 4, LAG_STEPS = 3, FOLLOW_DIST = 20, BEHIND_BIAS = 0.75;
    const MIN_SEP     = DOG.r + HUMAN.r + 4;
    const GRACE_MS    = 700;
    const MAX_DIFF    = 3, TIME_TO_MAX = 60;
    const INITIAL_OBSTACLES = 5;
    let nextObstacleTime = 15;

    let dog    = { x:0, y:0, vx:0, vy:0 };
    let human  = { x:0, y:0, vx:0, vy:0 };
    let dogDir = { x:0, y:-1 };
    let prevDog, trail = [];
    let elapsed = 0, running = true, difficulty = 1;
    let lastFrame = performance.now(), startTime;
    let warningBlinkTimer = 0, isWarning = false;

    // --- 아이템 정의 ---
    const ItemTypes = [{
      r:12, speedFactor: 0.6, color:'#a0a0ff',
      draw(ctx,x,y,r){
        ctx.save(); ctx.translate(x,y);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(0,0,r,0,2*Math.PI); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(-r*0.5,0);
        ctx.lineTo(0,-r*0.8);
        ctx.lineTo(r*0.5,0);
        ctx.lineTo(0,r*0.8);
        ctx.closePath(); ctx.stroke();
        ctx.restore();
      }
    }];
    class Item {
      constructor(type){ this.type = type; this.reset(); }
      reset(){
        const { r } = this.type;
        this.r   = r;
        this.x   = lane.x1 + r + Math.random()*(lane.x2-lane.x1-2*r);
        this.y   = -r - Math.random()*innerHeight*0.5;
        this.vy  = (200 + Math.random()*170) * this.type.speedFactor;
      }
      update(dt){
        this.y += this.vy * difficulty * dt;
        // 화면 밖으로 벗어난 개별 아이템만 배열에서 제거
     if (this.y - this.r > innerHeight) {
       const i = items.indexOf(this);
       if (i >= 0) items.splice(i, 1);
     }
      }
      draw(){ this.type.draw(ctx, this.x, this.y, this.r); }
    }

    // --- 장애물 정의 ---
    class Obstacle {
      constructor(type){ this.type = type; this.reset(); }
      reset(){
        this.r  = this.type.randomR();
        this.x  = lane.x1 + 18 + Math.random()*(lane.x2-lane.x1-36);
        this.y  = -this.r - Math.random()*innerHeight*1.2;
        this.vy = this.type.randomSpeed();
      }
      update(dt){
        const speedMul = 0.8 + (difficulty - 1)*0.4;
        this.y += this.vy * speedMul * dt;
        if (this.y - this.r > innerHeight) this.reset();
      }
      draw(){ this.type.draw(ctx, this.x, this.y, this.r); }
    }
    const ObTypes = [
      { // 콘
        randomR: ()=>15+Math.random()*4,
        randomSpeed: ()=>220+Math.random()*120,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#f97316';
          ctx.beginPath();
          ctx.moveTo(0,-r);
          ctx.lineTo(r*0.8,r*0.9);
          ctx.lineTo(-r*0.8,r*0.9);
          ctx.closePath(); ctx.fill();
          ctx.fillStyle='#fff';
          ctx.fillRect(-r*0.5,-r*0.3,r,r*0.18);
          ctx.fillRect(-r*0.45,r*0.2,r,r*0.16);
          ctx.restore();
        }
      },
      { // 봉?깃대?
        randomR: ()=>15+Math.random()*5,
        randomSpeed: ()=>220+Math.random()*170,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#555';
          ctx.fillRect(-r*0.4,-r*1.6,r*0.8,r*2.2);
          ctx.fillStyle='#ffcc00';
          ctx.fillRect(-r*0.5,-r*0.6,r,r*0.25);
          ctx.fillRect(-r*0.5,0,r,r*0.25);
          ctx.restore();
        }
      },
      { // 쓰레기통?
        randomR: ()=>25+Math.random()*4,
        randomSpeed: ()=>190+Math.random()*170,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#1f6b3a';
          ctx.fillRect(-r*0.8,-r*1.1,r*1.6,r*1.8);
          ctx.fillStyle='#184e2b';
          ctx.fillRect(-r*0.9,-r*1.2,r*1.8,r*0.25);
          ctx.restore();
        }
      },
      { // 타이어
        randomR: ()=>17+Math.random()*5,
        randomSpeed: ()=>200+Math.random()*135,
        draw(ctx,x,y,r){
          ctx.save(); ctx.translate(x,y);
          ctx.fillStyle='#2f2f2f';
          ctx.beginPath(); ctx.arc(0,0,r,0,2*Math.PI); ctx.fill();
          ctx.strokeStyle='#555'; ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(0,0,r*0.7,0,2*Math.PI); ctx.stroke();
          ctx.restore();
        }
      }
    ];
    let obstacles = [];

    // --- 레이아웃 & 입력 초기화 ---
    function resize(){
      cvs.width  = innerWidth;
      cvs.height = innerHeight;
      const W = innerWidth;
      const laneW = Math.min(W<=768?360:700, W-(W<=768?40:160));
      lane.x1 = (W-laneW)/2;
      lane.x2 = lane.x1 + laneW;
    }
    window.addEventListener('resize', resize);
    resize();

    const keys = {};
    ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD']
      .forEach(c=>keys[c]=false);
    window.addEventListener('keydown', e=>{
      if(e.code in keys){ keys[e.code]=true; e.preventDefault(); }
    });
    window.addEventListener('keyup', e=>{
      if(e.code in keys){ keys[e.code]=false; e.preventDefault(); }
    });

    let dragging=false, origin={x:0,y:0};
    joyContainer.addEventListener('pointerdown', e=>{
      e.preventDefault(); dragging=true;
      origin.x=e.clientX; origin.y=e.clientY;
    });
    window.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx=e.clientX-origin.x, dy=e.clientY-origin.y;
      const max=joyContainer.clientWidth/2-12;
      const dist=Math.min(Math.hypot(dx,dy), max);
      const ang=Math.atan2(dy,dx);
      joyStick.style.transform = `translate(${Math.cos(ang)*dist}px,${Math.sin(ang)*dist}px)`;
      joyDir = { x:Math.cos(ang)*(dist/max), y:Math.sin(ang)*(dist/max) };
    });
    window.addEventListener('pointerup', ()=>{
      dragging=false;
      joyStick.style.transform='translate(0,0)';
      joyDir={x:0,y:0};
    });

    function clampToLane(p, r){
      p.x = Math.max(lane.x1+r, Math.min(lane.x2-r, p.x));
      p.y = Math.max(r, Math.min(innerHeight-r, p.y));
    }
    function vecInput(){
      let x=(keys.ArrowRight||keys.KeyD)-(keys.ArrowLeft||keys.KeyA);
      let y=(keys.ArrowDown||keys.KeyS)-(keys.ArrowUp||keys.KeyW);
      x+=joyDir.x; y+=joyDir.y;
      const m=Math.hypot(x,y);
      return m>1?{x:x/m,y:y/m}:{x,y};
    }

    // --- 게임 초기화 ---
    function spawnObstacles(n){
      obstacles = Array.from({ length:n }, ()=>{
        const t=ObTypes[Math.floor(Math.random()*ObTypes.length)];
        return new Obstacle(t);
      });
    }
    function reset(){
      resize();
      dog.x = (lane.x1+lane.x2)/2; dog.y = innerHeight-140; dog.vx=dog.vy=0;
      human.x = dog.x; human.y = dog.y + Math.max(FOLLOW_DIST,MIN_SEP); human.vx=human.vy=0;
      trail = []; elapsed=0; running=true; difficulty=1;
      warningBlinkTimer=0; isWarning=false;
      prevDog={x:dog.x,y:dog.y};
      items=[]; itemSpawnAcc=0; shieldActive=false;
      spawnObstacles(INITIAL_OBSTACLES);
      nextObstacleTime=15;
      startTime = performance.now();
      overlay.style.display='none';
    }

    // --- 메인 업데이트 ---
    function update(dt){
      if(!running) return;
      elapsed += dt;
      difficulty = 1 + (MAX_DIFF-1)*Math.min(elapsed/TIME_TO_MAX,1);

      // 1초마다 10% 확률로 아이템 스폰 (최대 1개)
      itemSpawnAcc += dt;
      if(itemSpawnAcc >= 1){
        itemSpawnAcc = 0;
        if(items.length===0 && Math.random()<0.10){
          items.push(new Item(ItemTypes[0]));
        }
      }

      // 10초마다 장애물 1개 추가
      if(elapsed >= nextObstacleTime){
        obstacles.push(new Obstacle(ObTypes[Math.floor(Math.random()*ObTypes.length)]));
        nextObstacleTime += 10;
      }

      // 개 이동
      const dir = vecInput();
      dog.x += dir.x * DOG.speed * dt;
      dog.y += dir.y * DOG.speed * dt;
      clampToLane(dog, DOG.r);
      // 사람-개 거리, 경고, 줄 끊김
      const dx = dog.x - human.x, dy = dog.y - human.y;
      const dist = Math.hypot(dx, dy);
      if(dist > WARNING_DIST && dist <= MAX_DIST){
        isWarning = true; warningBlinkTimer += dt;
      } else {
        isWarning = false; warningBlinkTimer = 0;
      }
      if(dist > MAX_DIST){
        running = false;
        titleText.textContent = '줄이 끊어졌다';
      }

      // 트레일 기록
      if((trail._acc = (trail._acc||0) + dt*60) >= TRAIL_STEP){
        trail._acc = 0;
        trail.push({ x:dog.x, y:dog.y });
        if(trail.length > 1000) trail.shift();
      }

      // 개 진행 방향 보정
      const mvx = dog.x - prevDog.x, mvy = dog.y - prevDog.y;
      const mlen = Math.hypot(mvx, mvy);
      if(mlen > 0.15){
        const nx = mvx/mlen, ny = mvy/mlen;
        dogDir.x = dogDir.x*0.7 + nx*0.3;
        dogDir.y = dogDir.y*0.7 + ny*0.3;
        const dn = Math.hypot(dogDir.x, dogDir.y);
        dogDir.x /= dn; dogDir.y /= dn;
      }
      prevDog.x = dog.x; prevDog.y = dog.y;

      // 사람 이동 (지연 추적 + 앞질렀을 때 보정 + 겹침 방지)
      let tx = dog.x - dogDir.x * FOLLOW_DIST;
      let ty = dog.y - dogDir.y * FOLLOW_DIST;
      if(trail.length > LAG_STEPS){
        const pt = trail[trail.length - LAG_STEPS];
        tx = tx * (1 - BEHIND_BIAS) + pt.x * BEHIND_BIAS;
        ty = ty * (1 - BEHIND_BIAS) + pt.y * BEHIND_BIAS;
      }
      const hx = tx - human.x, hy = ty - human.y;
      const hdist = Math.hypot(hx, hy);
      if(hdist < 1.2){
        human.x = tx; human.y = ty; human.vx = human.vy = 0;
      } else {
        const nx = hx/hdist, ny = hy/hdist;
        const maxS = Math.min(HUMAN.speed*(1+Math.min(0.6, hdist/50)), 270);
        const desiredVx = nx*maxS, desiredVy = ny*maxS;
        human.vx += (desiredVx - human.vx) * Math.min(1, 800*dt);
        human.vy += (desiredVy - human.vy) * Math.min(1, 800*dt);
        human.vx *= 1 - Math.min(0.9, 16*dt);
        human.vy *= 1 - Math.min(0.9, 16*dt);
        const vmag = Math.hypot(human.vx, human.vy);
        if(vmag > maxS){
          human.vx = human.vx / vmag * maxS;
          human.vy = human.vy / vmag * maxS;
        }
        human.x += human.vx * dt;
        human.y += human.vy * dt;
      }

      // 사람-개 겹침 방지
      {
        const ddx = dog.x - human.x, ddy = dog.y - human.y;
        const sep = Math.hypot(ddx, ddy);
        if(sep < MIN_SEP){
          const nx = sep>0 ? ddx/sep : dogDir.x;
          const ny = sep>0 ? ddy/sep : dogDir.y;
          const fix = MIN_SEP - sep;
          human.x -= nx * fix;
          human.y -= ny * fix;
          human.vx *= 0.5;
          human.vy *= 0.5;
        }
      }
      clampToLane(human, HUMAN.r);

      // 장애물 업데이트 및 충돌 체크
      obstacles.forEach(o => o.update(dt));
items.forEach((it, idx) => {
  for (let i = items.length - 1; i >= 0; i--) {
  const it = items[i];
  it.update(dt);

  // 사람과 충돌 거리
  const distToHuman = Math.hypot(it.x - human.x, it.y - human.y);
  // 안내견과 충돌 거리
  const distToDog   = Math.hypot(it.x - dog.x,   it.y - dog.y);

  // 사람 또는 개와 닿으면 실드 획득
  if (distToHuman < it.r + HUMAN.r ||
      distToDog   < it.r + DOG.r) {
    shieldActive = true;
    items.splice(i, 1);           // 해당 아이템만 제거
    DOG.color = '#999999';        // 실드 색상 효과
  }
}
});
      if(performance.now() - startTime > GRACE_MS){
        for (const o of obstacles) {
  	const d1 = Math.hypot(o.x - dog.x, o.y - dog.y);
  	const d2 = Math.hypot(o.x - human.x, o.y - human.y);
  	if (d1 < o.r + DOG.r || d2 < o.r + HUMAN.r) {
    	// ↓ 이 부분을 아래처럼 교체
    	if (shieldActive) {
      	// 실드로 충돌 방어: 장애물 제거, 생성 개수 1개 감소
      	const idxO = obstacles.indexOf(o);
       	 if (idxO >= 0) obstacles.splice(idxO, 1);
       	 shieldActive = false;
       	 DOG.color = '#d4a44a';      // 원래 색상 복구
        	// 이후 spawnObstacles 사용 시 초기 개수도 감소시키려면
      	// INITIAL_OBSTACLES = Math.max(1, INITIAL_OBSTACLES - 1);
    	} else {
      	running = false;
      	titleText.textContent = '게임 종료';
             }
   	 break;
  	}
          }
       }

      timePill.textContent = `⏱️ ${elapsed.toFixed(2)} s`;
      if(!running){
        document.getElementById('finalTime').textContent = `걸은 시간: ${elapsed.toFixed(2)} s`;
        overlay.style.display = 'flex';
      }
    }

    // --- 그리기 ---
    function draw(){
      // 보도
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--lane');
      ctx.fillRect(lane.x1, 0, lane.x2 - lane.x1, innerHeight);
      // 바닥 패턴
      const ts = 40;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--stripe');
      ctx.lineWidth = 1;
      for(let y=0; y<innerHeight; y+=ts){
        for(let x=lane.x1; x<lane.x2; x+=ts){
          ctx.strokeRect(x,y,ts,ts);
        }
      }
      // 인도 외곽
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gutter');
      ctx.fillRect(0,0,lane.x1,innerHeight);
      ctx.fillRect(lane.x2,0,innerWidth-lane.x2,innerHeight);

      // 장애물
      obstacles.forEach(o => o.draw());

      // 하네스(줄)
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(human.x, human.y);
      ctx.lineTo(dog.x, dog.y);
      ctx.stroke();
      
      items.forEach(it => it.draw());

      // 사람
      ctx.fillStyle = HUMAN.color;
      ctx.beginPath();
      ctx.arc(human.x, human.y, HUMAN.r, 0, 2*Math.PI);
      ctx.fill();

      // 개
      const ang = Math.atan2(dogDir.y, dogDir.x) + Math.PI/2;
      ctx.save();
      ctx.translate(dog.x, dog.y);
      ctx.rotate(ang);
      ctx.fillStyle = DOG.color;
      ctx.strokeStyle = DOG.outline;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.ellipse(0,4,DOG.r*0.9,DOG.r*1.1,0,0,2*Math.PI);
      ctx.fill(); ctx.stroke();
      ctx.beginPath();
      ctx.arc(0,-DOG.r*0.6, DOG.r*0.6,0,2*Math.PI);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = DOG.ear;
      ctx.beginPath();
      ctx.arc(-DOG.r*0.35,-DOG.r*0.95,DOG.r*0.22,0,2*Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(DOG.r*0.35,-DOG.r*0.95,DOG.r*0.22,0,2*Math.PI);
      ctx.fill();
      ctx.strokeStyle = DOG.outline;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0,DOG.r*1.3);
      ctx.quadraticCurveTo(DOG.r*0.6,DOG.r*1.0,DOG.r*1.0,DOG.r*1.6);
      ctx.stroke();
      ctx.restore();

      // 경고 텍스트
      if(isWarning){
        const alpha = Math.abs(Math.sin(warningBlinkTimer * Math.PI * 3));
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = 'red';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('줄이 팽팽하다', dog.x, dog.y - DOG.r - 10);
        ctx.restore();
      }
    }

    // --- 메인 루프 ---
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.033, (now - lastFrame)/1000);
      lastFrame = now;
      update(dt);
      ctx.clearRect(0, 0, innerWidth, innerHeight);
      draw();
      requestAnimationFrame(loop);
    }

    retryBtn.addEventListener('click', reset);
    exitBtn .addEventListener('click', ()=> location.href='mainroom.html');

    reset();
    loop();
  })();
  </script>
</body>
</html>